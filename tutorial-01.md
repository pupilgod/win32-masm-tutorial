# Tutorial 1 - nasm汇编语言基础

> 这里我们假设读者已经安装了masm，如果你还没有安装masm，请在阅读下文前先点击[此处](http://www.masm32.com/download.htm)下载masm并安装

## 理论

Win32程序从Intel 80286([wiki百科](https://zh.wikipedia.org/wiki/Intel_80286))起就运行在保护模式下，但是到目前，80286显然是个古董了。所以我们只需要关心Intel 80386([wiki百科](https://zh.wikipedia.org/wiki/Intel_80386))及其后代版本

每一个Win32程序都运行在一个独立的虚拟空间里，这意味着每个Win32程序理论上可以拥有4GB的空间，程序可以使用此空间内的任何地址(0x00000000~0xFFFFFFFF)，我们无需关心如何得到这4GB的虚拟空间，Windows会为我们做好预备工作来使这4GB的空间索引有效。然而，这**并不**意味着每个Win32程序都有4GB的实际物理内存能用。当然，Win32应用程序也要遵守Windows的相关规则，否则可能会导致可怕的一般性保护错误。

在Win16下，所有的Win16应用程序都可以看到其他程序的数据，这一点与Win32下的表现不同。这也有助于减少一个程序改写另一个程序的数据或代码的机会。

现在的内存模型与昔日的16位操作系统截然不同，在Win32下，我们无需更多地关心内存模型与各种段。在Win32下只有一种内存模型 —— Flat，即平坦模型。这里没有额外的64KB段，内存是一整个4GB的连续的空间。这也意味着你不必非得使用寄存器。你可以向某些寄存器按规则写入地址数据，计算机会帮你自动索引到这个地址，这对程序员是一个极大的好处。使用Win32汇编开发Win32应用程序就像用C一样简单。

在Win32下开发程序的你，必须记住一件事 —— `esi` `edi` `ebp` `ebx` 这四个寄存器归Windows内部使用并且Windows不希望其值被修改

所以你要时刻记住 —— 以上规则并不意味着你不能使用这四个寄存器。当Windows将控制权交给你后，如果你使用了这四个寄存器中的任何一个，在归还控制权给Windows之前，务必要把这四个寄存器的值恢复到Windows将控制权交给你时的四个寄存器的值，这样Windows才能在你的程序结束后继续正常运行。你所编写的程序都是由Windows发起执行的。

## 正文

### 一个基本的Win32汇编程序

以下是一个基本的win32汇编程序，如果你不能理解其中的某些代码，无需担心，我会在稍后为你依次阐述。

``` asm
.386
.model flat, stdcall
.data
    < Here's your initialized data >
    ...
.data?
    < Here's your un-initialized data >
    ...
.const
    < Here's your constants >
    ...
.code
    < label >
    < Here's your some code >
    ...
    end < lable >
```

现在，让我们来一起分析它

### .386

这是一个汇编器标记，它指示汇编器使用80386指令集。其实你也可以使用 `.486` `.586`，但是最保险的选择还是 `.386` 。每种CPU体系实际上有两种几乎相同的形式，比如 `.386` 和 `.386p` ， `.486` 和 `.486p` 。这里的 `p` 后缀仅仅当你程序需要执行特权指令(privileged instruction)时才使用。特权指令在保护模式下无法执行，通常情况下我们进入到操作系统以后执行的程序都是在保护模式下执行的，所以我们通常无法使用特权指令，但是某情景下我们必须使用到特权指令，这你无需担心，当你真的需要用到特权指令时，系统自然会允许你执行特权指令，比如 Windows驱动开发。

### .model flat, stdcall

`.model` 时一个汇编器指令，它指定你的程序使用的内存模型。在上面我们提到过在Win32下只支持flat模型，所以这里我们也只能采用flat模型。

`stdcall` 指示masm使用何种参数传递约定。不同的约定决定了不同的参数传递的顺序，通常有从左到右，从右到左。同时，它还要在函数执行完成时保持堆栈平衡。

在16位机下，只有 `C` 和 `PASCAL` 两种调用约定。

#### 调用约定 - C

C调用约定是从右到左传递参数，右边的参数从右至左依次入栈，最左边的参数最后入栈，由调用者维护堆栈平衡。

举个例子

有这样一个C函数

```c
void foo(int first_param, int second_param, int third_param);
```

假设我们现在要调用这个 `foo` 函数，用汇编代码表示为

``` asm
push [third_param]  ; 先将第三个参数入栈
push [second_param] ; 随后将第二个参数入栈
push [first_param]  ; 最后将第一个参数入栈
call foo
add sp, 12          ; 由调用者维护堆栈平衡
```

#### 调用约定 - PASCAL

PASCAL调用约定与C调用约定刚好相反，它传递参数的顺序是从左到右，当函数即将返回时，由被调用者维护堆栈平衡。

Win16采用的时PASCAL调用约定，因为这样生成的代码会少一些。

现在我假设你写了一个函数，但是你并不知道有多少参数将要传递给函数，这时候C调用约定的用处就体现出来了。就像`wsprintf()`函数一样，在`wsprintf()`的情况下，函数无法确定堆栈中将push多少个参数，因此无法在函数返回前实现堆栈平衡，这时候就需要调用者去维护堆栈平衡。

#### 调用约定 - STDCALL

STDCALL调用约定是C调用约定和PASCAL调用约定的结合版。它的参数传递顺序是从右向左，堆栈平衡由被调用者维护。Win32下只使用stdcall，这意味着当你调用任何一个win32 api时，绝大多数情况下都是以stdcall调用约定去调用函数。这里有一个例外 `wsprintf()`，你必须使用C调用约定来调用此函数。

### .data .data? .const .code

这四个指令都是所谓的节（即 `section`），在Win32下没有段（即 `segment`）的概念。但是你可以在这些逻辑节上划分你的入口地址空间。记住，每一个节的开始都意味着前一个节的结束。（第一个节除外！！！）

所有的节有两个大类别：用于存放数据或者用于存放代码。

存储数据的节分为三个种类：

- `.DATA` 你可以在这个节里放入已经初始化好的数据。

- `.DATA?` 你可以在这个节里放入还未被初始化的数据。在某些情况下，你并不知道具体的数据是什么，但是你需要提前为这个数据开辟一个空间，因为在程序执行的某一时刻会向其存入或读出数据，这时候这个节就可以用于实现这个目的。它还有一个特点：他不会占用生成的可执行文件的空间。假如分配了100M大小的数据在这个节里，实际上生成的可执行文件并不会膨胀到100M。你只需要告诉编译器在程序载入内存时你需要多大的空间即可。

- `.CONST` 你可以在这个节里放入常量，这个节里的数据一经分配不能修改，因为他们是常量。

你不必在程序中使用全部三个节，只需要声明你要使用的节即可。

存放代码的节只有一个： `.CODE`，你的代码需要放进这个节里才会被执行。

< lable >
end < lable >

其中 < lable > 是任意的标签名，用于标记代码的范围。前后呼应的两个 < lable > 名字必须相同。你的代码必须写在 < lable > 和 end < lable > 之间

就像这样

``` asm
.code
    _start:             ; < lable >
        mov eax, 0
        add eax, 1
    end _start          ; end < lable >
```